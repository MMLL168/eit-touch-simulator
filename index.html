<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EITè§¸æ§æ„Ÿæ¸¬ç³»çµ± - å‹•æ…‹æ¨¡æ“¬</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Microsoft JhengHei', Arial, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            padding: 20px;
            min-height: 100vh;
        }
        .dashboard {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .panel {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        .full-width {
            grid-column: 1 / -1;
        }
        h2 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 18px;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }

        /* EIT æ„Ÿæ¸¬å€åŸŸ */
        .eit-container {
            position: relative;
            text-align: center;
        }
        #eitCanvas {
            border: 2px solid #34495e;
            border-radius: 10px;
            cursor: crosshair;
            background: #ecf0f1;
        }

        /* æ§åˆ¶é¢æ¿ */
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.2);
        }
        button:active {
            transform: translateY(0);
        }
        button.active {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        /* è¨Šè™Ÿæ³¢å½¢åœ– */
        #signalChart {
            width: 100%;
            height: 250px;
            border: 1px solid #bdc3c7;
            border-radius: 8px;
            background: #f8f9fa;
        }

        /* é›»å£“è®ŠåŒ–è¡¨ */
        .voltage-table {
            max-height: 400px;
            overflow-y: auto;
            font-size: 13px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th {
            background: #34495e;
            color: white;
            padding: 10px;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        td {
            padding: 8px;
            border-bottom: 1px solid #ecf0f1;
            text-align: center;
        }
        tr:hover {
            background: #e8f4f8;
        }
        .voltage-bar {
            height: 20px;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            border-radius: 3px;
            transition: width 0.3s;
        }

        /* è¨ˆç®—çµæœ */
        .result-box {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-top: 15px;
            text-align: center;
        }
        .result-box h3 {
            font-size: 16px;
            margin-bottom: 10px;
            opacity: 0.9;
        }
        .coordinates {
            font-size: 32px;
            font-weight: bold;
            margin: 10px 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        .accuracy {
            font-size: 14px;
            opacity: 0.85;
        }

        /* ç†±åœ– */
        #heatmapCanvas {
            border: 1px solid #bdc3c7;
            border-radius: 8px;
        }

        /* ç‹€æ…‹æŒ‡ç¤ºå™¨ */
        .status {
            display: flex;
            justify-content: space-around;
            margin-top: 15px;
            padding: 10px;
            background: #ecf0f1;
            border-radius: 8px;
        }
        .status-item {
            text-align: center;
        }
        .status-label {
            font-size: 12px;
            color: #7f8c8d;
            margin-bottom: 5px;
        }
        .status-value {
            font-size: 20px;
            font-weight: bold;
            color: #2c3e50;
        }
        .status-value.active {
            color: #e74c3c;
            animation: blink 1s infinite;
        }
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* åœ–ä¾‹ */
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 10px;
            font-size: 12px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #2c3e50;
        }
    </style>
</head>
<body>
    <div class="dashboard">
        <!-- EITæ„Ÿæ¸¬å€åŸŸ -->
        <div class="panel">
            <h2>ğŸ¯ EITè§¸æ§æ„Ÿæ¸¬å¹³é¢ (30cm)</h2>
            <div class="eit-container">
                <canvas id="eitCanvas" width="500" height="500"></canvas>
            </div>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #3498db;"></div>
                    <span>å¾…æ©Ÿé›»æ¥µ</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #e74c3c;"></div>
                    <span>TXç™¼å°„</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #2ecc71;"></div>
                    <span>RXæ¥æ”¶</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #f39c12;"></div>
                    <span>æ‰‹æŒ‡è§¸æ§</span>
                </div>
            </div>
            <div class="status">
                <div class="status-item">
                    <div class="status-label">TXé›»æ¥µ</div>
                    <div class="status-value" id="txStatus">-</div>
                </div>
                <div class="status-item">
                    <div class="status-label">RXé›»æ¥µæ•¸</div>
                    <div class="status-value" id="rxStatus">0</div>
                </div>
                <div class="status-item">
                    <div class="status-label">æ¸¬é‡é »ç‡</div>
                    <div class="status-value active">50kHz</div>
                </div>
                <div class="status-item">
                    <div class="status-label">æ¿€å‹µé›»æµ</div>
                    <div class="status-value">2.5mA</div>
                </div>
            </div>
        </div>

        <!-- é˜»æŠ—åˆ†å¸ƒç†±åœ– -->
        <div class="panel">
            <h2>ğŸ”¥ é˜»æŠ—åˆ†å¸ƒç†±åœ–</h2>
            <canvas id="heatmapCanvas" width="460" height="460"></canvas>
            <div class="result-box">
                <h3>ğŸ“ è¨ˆç®—è§¸æ§ä½ç½® (åŠ æ¬Šè³ªå¿ƒæ³•)</h3>
                <div class="coordinates" id="touchCoords">ç­‰å¾…è§¸æ§...</div>
                <div class="accuracy">å®šä½ç²¾åº¦: <span id="accuracy">-</span></div>
            </div>
        </div>

        <!-- RXé›»å£“è®ŠåŒ–è¡¨ -->
        <div class="panel">
            <h2>ğŸ“Š å„é›»æ¥µé›»å£“è®ŠåŒ– (Î”V)</h2>
            <div class="voltage-table">
                <table id="voltageTable">
                    <thead>
                        <tr>
                            <th>é›»æ¥µ</th>
                            <th>åŸºæº–é›»å£“ (V)</th>
                            <th>æ¸¬é‡é›»å£“ (V)</th>
                            <th>è®ŠåŒ–é‡ (mV)</th>
                            <th>è®ŠåŒ–ç‡</th>
                        </tr>
                    </thead>
                    <tbody id="voltageBody"></tbody>
                </table>
            </div>
        </div>

        <!-- è¨Šè™Ÿæ³¢å½¢åœ– -->
        <div class="panel">
            <h2>ğŸ“ˆ RXè¨Šè™Ÿå¼·åº¦åˆ†å¸ƒ</h2>
            <canvas id="signalChart"></canvas>
            <div class="controls">
                <button onclick="startAutoScan()">è‡ªå‹•æƒææ¨¡å¼</button>
                <button onclick="stopScan()">åœæ­¢æƒæ</button>
                <button onclick="clearTouch()">æ¸…é™¤è§¸æ§</button>
                <button onclick="exportData()">åŒ¯å‡ºæ•¸æ“š</button>
            </div>
        </div>
    </div>

    <script>
        // ç³»çµ±åƒæ•¸
        const NUM_ELECTRODES = 20;
        const CENTER_X = 250;
        const CENTER_Y = 250;
        const RADIUS = 200;
        const ELECTRODE_RADIUS = 10;

        // Canvas åˆå§‹åŒ–
        const eitCanvas = document.getElementById('eitCanvas');
        const eitCtx = eitCanvas.getContext('2d');
        const heatmapCanvas = document.getElementById('heatmapCanvas');
        const heatmapCtx = heatmapCanvas.getContext('2d');
        const signalCanvas = document.getElementById('signalChart');
        const signalCtx = signalCanvas.getContext('2d');

        // é›»æ¥µæ•¸æ“š
        let electrodes = [];
        let currentTX = 1;
        let touchPoint = null;
        let baselineVoltages = [];
        let measuredVoltages = [];
        let scanInterval = null;

        // åˆå§‹åŒ–é›»æ¥µ
        function initElectrodes() {
            electrodes = [];
            for (let i = 0; i < NUM_ELECTRODES; i++) {
                const angle = (i * 360 / NUM_ELECTRODES - 90) * Math.PI / 180;
                electrodes.push({
                    id: i + 1,
                    x: CENTER_X + RADIUS * Math.cos(angle),
                    y: CENTER_Y + RADIUS * Math.sin(angle),
                    angle: angle
                });
            }
            // åˆå§‹åŒ–åŸºæº–é›»å£“ (æ¨¡æ“¬)
            baselineVoltages = Array(NUM_ELECTRODES).fill(0).map(() => 3.3 + (Math.random() - 0.5) * 0.1);
        }

        // ç¹ªè£½EITæ„Ÿæ¸¬å¹³é¢
        function drawEIT() {
            eitCtx.clearRect(0, 0, eitCanvas.width, eitCanvas.height);

            // æ„Ÿæ¸¬å€åŸŸ
            eitCtx.beginPath();
            eitCtx.arc(CENTER_X, CENTER_Y, RADIUS, 0, 2 * Math.PI);
            eitCtx.fillStyle = '#f0f4f8';
            eitCtx.fill();
            eitCtx.strokeStyle = '#34495e';
            eitCtx.lineWidth = 2;
            eitCtx.stroke();

            // ç¹ªè£½é›»å ´ç·š (è¦–è¦ºåŒ–æ•ˆæœ)
            if (touchPoint) {
                drawFieldLines();
            }

            // ç¹ªè£½é›»æ¥µ
            electrodes.forEach((e, idx) => {
                eitCtx.beginPath();
                eitCtx.arc(e.x, e.y, ELECTRODE_RADIUS, 0, 2 * Math.PI);

                if (e.id === currentTX) {
                    eitCtx.fillStyle = '#e74c3c';
                    eitCtx.strokeStyle = '#c0392b';
                } else if (touchPoint) {
                    eitCtx.fillStyle = '#2ecc71';
                    eitCtx.strokeStyle = '#27ae60';
                } else {
                    eitCtx.fillStyle = '#3498db';
                    eitCtx.strokeStyle = '#2980b9';
                }

                eitCtx.lineWidth = 2;
                eitCtx.fill();
                eitCtx.stroke();

                // é›»æ¥µç·¨è™Ÿ
                eitCtx.fillStyle = 'white';
                eitCtx.font = 'bold 11px Arial';
                eitCtx.textAlign = 'center';
                eitCtx.textBaseline = 'middle';
                eitCtx.fillText(e.id, e.x, e.y);
            });

            // ç¹ªè£½æ‰‹æŒ‡è§¸æ§é»
            if (touchPoint) {
                // æ‰‹æŒ‡åœ–å½¢
                eitCtx.beginPath();
                eitCtx.arc(touchPoint.x, touchPoint.y, 15, 0, 2 * Math.PI);
                eitCtx.fillStyle = 'rgba(243, 156, 18, 0.7)';
                eitCtx.fill();
                eitCtx.strokeStyle = '#e67e22';
                eitCtx.lineWidth = 3;
                eitCtx.stroke();

                // é˜»æŠ—å½±éŸ¿ç¯„åœ
                eitCtx.beginPath();
                eitCtx.arc(touchPoint.x, touchPoint.y, 40, 0, 2 * Math.PI);
                eitCtx.strokeStyle = 'rgba(231, 76, 60, 0.3)';
                eitCtx.lineWidth = 2;
                eitCtx.setLineDash([5, 5]);
                eitCtx.stroke();
                eitCtx.setLineDash([]);

                // åº§æ¨™æ¨™è¨»
                eitCtx.fillStyle = '#2c3e50';
                eitCtx.font = 'bold 12px Arial';
                eitCtx.fillText(`ğŸ‘† (${touchPoint.x - CENTER_X}, ${touchPoint.y - CENTER_Y})`, 
                               touchPoint.x, touchPoint.y - 50);
            }
        }

        // ç¹ªè£½é›»å ´ç·š
        function drawFieldLines() {
            const txElectrode = electrodes[currentTX - 1];

            electrodes.forEach(rxElectrode => {
                if (rxElectrode.id === currentTX) return;

                // è¨ˆç®—é›»å ´ç·šå—æ‰‹æŒ‡å½±éŸ¿çš„å½æ›²
                const distToTouch = Math.hypot(touchPoint.x - (txElectrode.x + rxElectrode.x) / 2,
                                               touchPoint.y - (txElectrode.y + rxElectrode.y) / 2);
                const influence = Math.max(0, 1 - distToTouch / 100);

                eitCtx.beginPath();
                eitCtx.moveTo(txElectrode.x, txElectrode.y);

                // è²èŒ²æ›²ç·šæ¨¡æ“¬é›»å ´ç·šå½æ›²
                const cpx = (txElectrode.x + rxElectrode.x) / 2 + (touchPoint.x - CENTER_X) * influence * 0.3;
                const cpy = (txElectrode.y + rxElectrode.y) / 2 + (touchPoint.y - CENTER_Y) * influence * 0.3;

                eitCtx.quadraticCurveTo(cpx, cpy, rxElectrode.x, rxElectrode.y);
                eitCtx.strokeStyle = `rgba(52, 152, 219, ${0.1 + influence * 0.4})`;
                eitCtx.lineWidth = 1 + influence * 2;
                eitCtx.stroke();
            });
        }

        // è¨ˆç®—æ¸¬é‡é›»å£“ (æ¨¡æ“¬é˜»æŠ—è®ŠåŒ–)
        function calculateVoltages() {
            if (!touchPoint) {
                measuredVoltages = [...baselineVoltages];
                return;
            }

            const txElectrode = electrodes[currentTX - 1];
            measuredVoltages = electrodes.map((rxElectrode, idx) => {
                if (rxElectrode.id === currentTX) return baselineVoltages[idx];

                // è¨ˆç®—é›»æ¥µåˆ°è§¸æ§é»çš„è·é›¢
                const distToTouch = Math.hypot(touchPoint.x - rxElectrode.x, touchPoint.y - rxElectrode.y);

                // è¨ˆç®—TX-è§¸æ§é»-RXè·¯å¾‘çš„é˜»æŠ—è®ŠåŒ–
                const pathDistToTouch = calculatePathDistance(txElectrode, rxElectrode, touchPoint);

                // é˜»æŠ—è®ŠåŒ–å°è‡´é›»å£“è¡°æ¸› (è·é›¢è¶Šè¿‘è¡°æ¸›è¶Šå¤§)
                const impedanceEffect = Math.exp(-pathDistToTouch / 60);
                const voltageDrop = baselineVoltages[idx] * 0.3 * impedanceEffect;

                return baselineVoltages[idx] - voltageDrop + (Math.random() - 0.5) * 0.01;
            });
        }

        // è¨ˆç®—è·¯å¾‘è·é›¢
        function calculatePathDistance(tx, rx, touch) {
            const midX = (tx.x + rx.x) / 2;
            const midY = (tx.y + rx.y) / 2;
            return Math.hypot(touch.x - midX, touch.y - midY);
        }

        // æ›´æ–°é›»å£“è¡¨
        function updateVoltageTable() {
            const tbody = document.getElementById('voltageBody');
            tbody.innerHTML = '';

            electrodes.forEach((e, idx) => {
                if (e.id === currentTX) return;

                const baseV = baselineVoltages[idx];
                const measV = measuredVoltages[idx];
                const deltaV = (baseV - measV) * 1000; // è½‰æ›ç‚ºmV
                const changePercent = ((deltaV / (baseV * 1000)) * 100).toFixed(2);

                const row = tbody.insertRow();
                row.innerHTML = `
                    <td><strong>RX${e.id}</strong></td>
                    <td>${baseV.toFixed(3)}</td>
                    <td>${measV.toFixed(3)}</td>
                    <td style="color: ${deltaV > 0 ? '#e74c3c' : '#2ecc71'}">
                        <strong>${deltaV.toFixed(2)}</strong>
                    </td>
                    <td>
                        <div style="width: 100%; background: #ecf0f1; border-radius: 3px; overflow: hidden;">
                            <div class="voltage-bar" style="width: ${Math.abs(changePercent)}%"></div>
                        </div>
                        ${changePercent}%
                    </td>
                `;
            });
        }

        // ç¹ªè£½è¨Šè™Ÿå¼·åº¦åœ–
        function drawSignalChart() {
            const width = signalCanvas.width;
            const height = signalCanvas.height;
            signalCtx.clearRect(0, 0, width, height);

            // èƒŒæ™¯ç¶²æ ¼
            signalCtx.strokeStyle = '#ecf0f1';
            signalCtx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const y = (height / 5) * i;
                signalCtx.beginPath();
                signalCtx.moveTo(0, y);
                signalCtx.lineTo(width, y);
                signalCtx.stroke();
            }

            // ç¹ªè£½è¨Šè™Ÿæ¢
            const barWidth = width / NUM_ELECTRODES;
            electrodes.forEach((e, idx) => {
                if (e.id === currentTX) return;

                const deltaV = Math.abs(baselineVoltages[idx] - measuredVoltages[idx]);
                const barHeight = (deltaV / 0.5) * height * 0.8;

                const x = idx * barWidth;
                const y = height - barHeight;

                // æ¼¸å±¤è‰²
                const gradient = signalCtx.createLinearGradient(x, y, x, height);
                gradient.addColorStop(0, '#e74c3c');
                gradient.addColorStop(1, '#3498db');

                signalCtx.fillStyle = gradient;
                signalCtx.fillRect(x, y, barWidth - 2, barHeight);

                // é›»æ¥µæ¨™ç±¤
                signalCtx.fillStyle = '#2c3e50';
                signalCtx.font = '10px Arial';
                signalCtx.textAlign = 'center';
                signalCtx.fillText(e.id, x + barWidth / 2, height - 5);
            });
        }

        // ç¹ªè£½ç†±åœ–
        function drawHeatmap() {
            const width = heatmapCanvas.width;
            const height = heatmapCanvas.height;
            const imageData = heatmapCtx.createImageData(width, height);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const dx = x - width / 2;
                    const dy = y - height / 2;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist > RADIUS * 0.92) {
                        // é‚Šç•Œå¤–
                        const idx = (y * width + x) * 4;
                        imageData.data[idx] = 236;
                        imageData.data[idx + 1] = 240;
                        imageData.data[idx + 2] = 241;
                        imageData.data[idx + 3] = 255;
                        continue;
                    }

                    // è¨ˆç®—è©²é»çš„é˜»æŠ—å€¼ (åŸºæ–¼è§¸æ§é»è·é›¢)
                    let impedance = 1.0;
                    if (touchPoint) {
                        const touchDx = x - (touchPoint.x - CENTER_X + width / 2);
                        const touchDy = y - (touchPoint.y - CENTER_Y + height / 2);
                        const touchDist = Math.sqrt(touchDx * touchDx + touchDy * touchDy);
                        impedance = 1.0 - Math.exp(-touchDist / 40) * 0.8;
                    }

                    // ç†±åœ–é¡è‰²æ˜ å°„
                    const [r, g, b] = impedanceToColor(impedance);
                    const idx = (y * width + x) * 4;
                    imageData.data[idx] = r;
                    imageData.data[idx + 1] = g;
                    imageData.data[idx + 2] = b;
                    imageData.data[idx + 3] = 255;
                }
            }

            heatmapCtx.putImageData(imageData, 0, 0);

            // ç¹ªè£½é›»æ¥µä½ç½®
            electrodes.forEach(e => {
                const hx = e.x - CENTER_X + width / 2;
                const hy = e.y - CENTER_Y + height / 2;
                heatmapCtx.beginPath();
                heatmapCtx.arc(hx, hy, 6, 0, 2 * Math.PI);
                heatmapCtx.fillStyle = e.id === currentTX ? '#e74c3c' : '#34495e';
                heatmapCtx.fill();
                heatmapCtx.strokeStyle = 'white';
                heatmapCtx.lineWidth = 2;
                heatmapCtx.stroke();
            });
        }

        // é˜»æŠ—å€¼è½‰é¡è‰²
        function impedanceToColor(value) {
            // è—è‰²(ä½é˜»æŠ—) -> ç´…è‰²(é«˜é˜»æŠ—)
            const r = Math.floor(value * 231 + 24);
            const g = Math.floor((1 - value) * 152 + 108);
            const b = Math.floor((1 - value) * 219 + 60);
            return [r, g, b];
        }

        // è¨ˆç®—è§¸æ§ä½ç½® (åŠ æ¬Šè³ªå¿ƒæ³•)
        function calculateTouchPosition() {
            if (!touchPoint) {
                document.getElementById('touchCoords').textContent = 'ç­‰å¾…è§¸æ§...';
                document.getElementById('accuracy').textContent = '-';
                return;
            }

            let sumX = 0, sumY = 0, sumWeight = 0;

            electrodes.forEach((e, idx) => {
                if (e.id === currentTX) return;

                const weight = Math.abs(baselineVoltages[idx] - measuredVoltages[idx]);
                sumX += e.x * weight;
                sumY += e.y * weight;
                sumWeight += weight;
            });

            const calcX = Math.round(sumX / sumWeight - CENTER_X);
            const calcY = Math.round(sumY / sumWeight - CENTER_Y);

            // è¨ˆç®—èª¤å·®
            const actualX = touchPoint.x - CENTER_X;
            const actualY = touchPoint.y - CENTER_Y;
            const error = Math.sqrt((calcX - actualX) ** 2 + (calcY - actualY) ** 2);
            const accuracy = Math.max(0, 100 - error / 2).toFixed(1);

            document.getElementById('touchCoords').textContent = `X: ${calcX}mm, Y: ${calcY}mm`;
            document.getElementById('accuracy').textContent = `${accuracy}% (èª¤å·®: ${error.toFixed(1)}mm)`;
        }

        // æ»‘é¼ é»æ“Šäº‹ä»¶
        eitCanvas.addEventListener('click', (e) => {
            const rect = eitCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const dist = Math.hypot(x - CENTER_X, y - CENTER_Y);
            if (dist <= RADIUS - 20) {
                touchPoint = { x, y };
                updateSimulation();
            }
        });

        // æ›´æ–°æ¨¡æ“¬
        function updateSimulation() {
            calculateVoltages();
            drawEIT();
            drawHeatmap();
            updateVoltageTable();
            drawSignalChart();
            calculateTouchPosition();
            updateStatus();
        }

        // æ›´æ–°ç‹€æ…‹é¡¯ç¤º
        function updateStatus() {
            document.getElementById('txStatus').textContent = `#${currentTX}`;
            document.getElementById('rxStatus').textContent = NUM_ELECTRODES - 1;
        }

        // è‡ªå‹•æƒæ
        function startAutoScan() {
            if (scanInterval) return;

            scanInterval = setInterval(() => {
                currentTX = (currentTX % NUM_ELECTRODES) + 1;

                // éš¨æ©Ÿç§»å‹•è§¸æ§é»
                if (touchPoint) {
                    touchPoint.x += (Math.random() - 0.5) * 20;
                    touchPoint.y += (Math.random() - 0.5) * 20;

                    // é™åˆ¶åœ¨åœ“å…§
                    const dist = Math.hypot(touchPoint.x - CENTER_X, touchPoint.y - CENTER_Y);
                    if (dist > RADIUS - 20) {
                        const angle = Math.atan2(touchPoint.y - CENTER_Y, touchPoint.x - CENTER_X);
                        touchPoint.x = CENTER_X + (RADIUS - 30) * Math.cos(angle);
                        touchPoint.y = CENTER_Y + (RADIUS - 30) * Math.sin(angle);
                    }
                } else {
                    // éš¨æ©Ÿç”¢ç”Ÿè§¸æ§é»
                    const angle = Math.random() * 2 * Math.PI;
                    const r = Math.random() * (RADIUS - 50) + 30;
                    touchPoint = {
                        x: CENTER_X + r * Math.cos(angle),
                        y: CENTER_Y + r * Math.sin(angle)
                    };
                }

                updateSimulation();
            }, 500);
        }

        // åœæ­¢æƒæ
        function stopScan() {
            if (scanInterval) {
                clearInterval(scanInterval);
                scanInterval = null;
            }
        }

        // æ¸…é™¤è§¸æ§
        function clearTouch() {
            touchPoint = null;
            updateSimulation();
        }

        // åŒ¯å‡ºæ•¸æ“š
        function exportData() {
            const data = {
                timestamp: new Date().toISOString(),
                txElectrode: currentTX,
                touchPoint: touchPoint ? {
                    x: Math.round(touchPoint.x - CENTER_X),
                    y: Math.round(touchPoint.y - CENTER_Y)
                } : null,
                voltages: electrodes.map((e, idx) => ({
                    electrode: e.id,
                    baseline: baselineVoltages[idx].toFixed(4),
                    measured: measuredVoltages[idx].toFixed(4),
                    delta: (baselineVoltages[idx] - measuredVoltages[idx]).toFixed(4)
                }))
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `eit_data_${Date.now()}.json`;
            a.click();
        }

        // åˆå§‹åŒ–
        initElectrodes();
        currentTX = 1;
        updateSimulation();
    </script>
</body>
</html>