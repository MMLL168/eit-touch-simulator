<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EIT 響應式儀表板 (Auto-Scaling Charts)</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', 'Microsoft JhengHei', sans-serif;
            background: #1a1c23;
            color: #e0e0e0;
            padding: 20px;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
        }

        .dashboard {
            width: 100%;
            height: 100%;
            max-width: 1600px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1.2fr 0.8fr;
            grid-template-rows: 45% 1fr; /* 稍微調整比例讓下方空間更多 */
            gap: 15px;
        }

        .panel {
            background: #252830;
            border-radius: 12px;
            padding: 15px;
            border: 1px solid #333;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        h2 {
            color: #fff;
            margin-bottom: 8px;
            font-size: 1rem;
            border-left: 4px solid #00d2ff;
            padding-left: 10px;
            letter-spacing: 1px;
            text-transform: uppercase;
            flex-shrink: 0;
        }

        /* 左側：物理感測區 */
        .eit-section { grid-row: span 2; }
        .eit-container { 
            flex: 1; 
            width: 100%; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            overflow: hidden; 
            position: relative;
        }
        #eitCanvas {
            width: auto; height: auto;
            max-width: 100%; max-height: 100%;
            border-radius: 50%;
            background: #1e2128;
            box-shadow: 0 0 40px rgba(0, 210, 255, 0.05);
            cursor: crosshair;
        }

        /* 右側上：數據分析 */
        .analysis-section { 
            display: grid; 
            grid-template-columns: 180px 1fr; 
            gap: 15px;
        }
        .heatmap-container {
            display: flex; flex-direction: column; 
            justify-content: center; align-items: center;
        }
        #heatmapCanvas {
            width: 100%; aspect-ratio: 1;
            border-radius: 8px; border: 1px solid #444; background: #000;
        }
        .data-panel {
            display: flex; flex-direction: column; justify-content: space-between;
        }
        .data-card {
            background: #2f343f; padding: 10px; border-radius: 6px; 
            text-align: center; margin-bottom: 8px;
        }
        .data-label { font-size: 0.75rem; color: #888; margin-bottom: 2px;}
        .data-value { font-size: 1.1rem; font-weight: bold; color: #00d2ff; }
        .coord-value { font-size: 1.4rem; color: #ffeb3b; text-shadow: 0 0 10px rgba(255,235,59,0.2);}
        
        .controls { display: flex; gap: 8px; margin-top: auto;}
        button {
            flex: 1; padding: 8px 0; border: none; border-radius: 4px;
            font-weight: bold; cursor: pointer; transition: 0.2s;
            background: #3a3f4b; color: white; font-size: 0.85rem;
        }
        button:hover { background: #4a505e; }
        button.primary { background: #00d2ff; color: #000; }
        button.danger { background: #ff4757; color: white; }

        /* 右側下：訊號與表格 */
        .signal-section { min-height: 0; display: flex; flex-direction: column; }
        
        .chart-container {
            flex-shrink: 0;
            height: 140px; /* 增加圖表高度 */
            width: 100%;
            background: #1e2128;
            border-radius: 4px;
            margin-bottom: 10px;
            border: 1px solid #333;
            position: relative; /* For scale text positioning */
        }
        #signalChart { width: 100%; height: 100%; }

        .voltage-scroll {
            flex: 1; overflow-y: auto;
            border: 1px solid #333; border-radius: 4px; background: #1e2128;
        }
        .voltage-scroll::-webkit-scrollbar { width: 6px; }
        .voltage-scroll::-webkit-scrollbar-thumb { background: #555; border-radius: 3px; }
        
        table { width: 100%; border-collapse: collapse; font-size: 0.8rem; }
        th { background: #2f343f; padding: 6px; position: sticky; top: 0; color: #ccc; z-index: 2; }
        td { padding: 4px; border-bottom: 1px solid #333; text-align: center; color: #ccc; }
        .high-delta { color: #ff4757; font-weight: bold; }
        .bar-container { width: 100%; height: 4px; background: #333; border-radius: 2px; }
        .bar-fill { height: 100%; background: #00d2ff; }

        @media (max-width: 1024px) {
            body { overflow: auto; height: auto; }
            .dashboard { display: flex; flex-direction: column; height: auto; }
            .eit-section { height: 500px; }
            .signal-section { height: 600px; }
        }
    </style>
</head>
<body>

<div class="dashboard">
    <div class="panel eit-section">
        <h2>Physical Sensor (30cm)</h2>
        <div class="eit-container">
            <canvas id="eitCanvas" width="600" height="600"></canvas>
        </div>
        <div style="text-align: center; font-size: 0.8rem; color: #666; margin-top:5px;">
            ● 紅色:TX | 藍色:RX | 黃色:計算位置
        </div>
    </div>

    <div class="panel analysis-section">
        <div class="heatmap-container">
            <canvas id="heatmapCanvas" width="200" height="200"></canvas>
            <div style="font-size:0.7rem; color:#666; margin-top:5px;">Reconstruction</div>
        </div>
        <div class="data-panel">
            <div>
                <div class="data-card">
                    <div class="data-label">Position (X, Y)</div>
                    <div class="data-value coord-value" id="coordDisplay">-- , --</div>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                    <div class="data-card">
                        <div class="data-label">Accuracy</div>
                        <div class="data-value" id="accDisplay">--%</div>
                    </div>
                    <div class="data-card">
                        <div class="data-label">Peak ΔV</div>
                        <div class="data-value" id="peakDisplay">0 mV</div>
                    </div>
                </div>
            </div>
            <div class="controls">
                <button class="primary" onclick="toggleAutoScan()" id="btnScan">Auto Scan</button>
                <button class="danger" onclick="clearTouch()">Clear</button>
            </div>
        </div>
    </div>

    <div class="panel signal-section">
        <div style="display:flex; justify-content:space-between; margin-bottom:5px;">
            <h2>Signals (ΔV)</h2>
            <span style="font-size:0.8rem; color:#888;">TX: <span id="txIndicator" style="color:#ff4757; font-weight:bold;">CH1</span></span>
        </div>
        
        <div class="chart-container">
            <canvas id="signalChart"></canvas>
        </div>
        
        <div class="voltage-scroll">
            <table id="voltageTable">
                <thead>
                    <tr>
                        <th width="15%">CH</th>
                        <th width="20%">Base</th>
                        <th width="20%">Meas</th>
                        <th width="20%">Δ(mV)</th>
                        <th width="25%">Level</th>
                    </tr>
                </thead>
                <tbody id="voltageBody"></tbody>
            </table>
        </div>
    </div>
</div>

<script>
    const CONFIG = {
        electrodes: 20,
        radius_outer: 250,
        elec_width: 20,
        gap_ratio: 0.25,
        center_x: 300,
        center_y: 300
    };

    let electrodes = [];
    let currentTX = 0;
    let touchPoint = null;
    let isScanning = false;
    let scanTimer = null;
    
    // UI Elements
    const ctxEIT = document.getElementById('eitCanvas').getContext('2d');
    const ctxHeat = document.getElementById('heatmapCanvas').getContext('2d');
    const ctxSignal = document.getElementById('signalChart').getContext('2d');

    // Canvas Resize Handler
    function resizeCharts() {
        const container = document.querySelector('.chart-container');
        const chart = document.getElementById('signalChart');
        // 使用 clientWidth 確保填滿容器
        chart.width = container.clientWidth;
        chart.height = container.clientHeight;
        drawSignals();
    }
    window.addEventListener('resize', resizeCharts);

    function init() {
        const stepAngle = (2 * Math.PI) / CONFIG.electrodes;
        const gapAngle = stepAngle * CONFIG.gap_ratio;
        const arcAngle = stepAngle - gapAngle;

        for (let i = 0; i < CONFIG.electrodes; i++) {
            const midAngle = (i * stepAngle) - (Math.PI / 2);
            const startAngle = midAngle - (arcAngle / 2);
            const endAngle = midAngle + (arcAngle / 2);
            const centerR = CONFIG.radius_outer - (CONFIG.elec_width / 2);
            
            electrodes.push({
                id: i + 1,
                startAngle: startAngle,
                endAngle: endAngle,
                midAngle: midAngle,
                cx: CONFIG.center_x + centerR * Math.cos(midAngle),
                cy: CONFIG.center_y + centerR * Math.sin(midAngle),
                baseV: 3.3,
                currentV: 3.3
            });
        }
        
        resizeCharts();
        requestAnimationFrame(animate);
    }

    function animate() {
        simulatePhysics();
        drawPhysicalView();
        drawHeatmap();
        drawSignals(); // 每一幀重繪
        updateTable();
        document.getElementById('txIndicator').innerText = `CH${currentTX+1}`;
        requestAnimationFrame(animate);
    }

    function simulatePhysics() {
        if (!touchPoint) {
            electrodes.forEach(e => e.currentV = e.baseV);
            return;
        }

        const txElec = electrodes[currentTX];
        electrodes.forEach((rx, idx) => {
            if (idx === currentTX) { rx.currentV = rx.baseV; return; }

            const d_tx_rx = Math.hypot(txElec.cx - rx.cx, txElec.cy - rx.cy);
            const d_finger_tx = Math.hypot(touchPoint.x - txElec.cx, touchPoint.y - txElec.cy);
            const d_finger_rx = Math.hypot(touchPoint.x - rx.cx, touchPoint.y - rx.cy);
            const ellipseFactor = (d_finger_tx + d_finger_rx) / d_tx_rx;

            let perturbation = 0;
            // 模擬手指靠近時阻抗劇烈變化
            if (ellipseFactor < 2.0) { 
                // 指數衰減模擬電場強度
                const strength = Math.exp(-(ellipseFactor - 1) * 3.5); 
                // 擾動量 (最大 1.5V)
                perturbation = strength * 1.5; 
            }
            rx.currentV = rx.baseV - perturbation + (Math.random()-0.5)*0.005; // 加一點雜訊
        });
        calculatePosition();
    }

    // --- 改進重點：自動縮放直條圖 ---
    function drawSignals() {
        const canvas = document.getElementById('signalChart');
        const w = canvas.width;
        const h = canvas.height;
        const ctx = ctxSignal;

        ctx.clearRect(0, 0, w, h);
        
        // 1. 找出當前所有電極中，最大的 ΔV (用來決定 Y 軸上限)
        let maxDelta = 0.001; // 避免除以零
        electrodes.forEach((e, i) => {
            if (i === currentTX) return;
            const d = Math.abs(e.baseV - e.currentV);
            if (d > maxDelta) maxDelta = d;
        });

        // 2. 設定動態上限 (Ceiling)：最大值再多留 20% 緩衝
        // 為了避免噪音造成圖表一直跳動，設定一個最小顯示範圍 (例如 0.5V)
        const scaleCeiling = Math.max(0.5, maxDelta * 1.2); 

        // 3. 繪製背景網格線 (Scale Lines)
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        ctx.beginPath();
        // 50% 線
        ctx.moveTo(0, h/2); ctx.lineTo(w, h/2);
        ctx.stroke();

        // 4. 繪製 Bar
        const barW = w / CONFIG.electrodes;
        electrodes.forEach((e, i) => {
            const delta = Math.abs(e.baseV - e.currentV);
            
            // 核心公式：高度 = (當前值 / 上限值) * Canvas高度
            let barHeight = (delta / scaleCeiling) * h;
            
            // 確保不超過 Canvas
            if (barHeight > h) barHeight = h;

            const x = i * barW;
            const y = h - barHeight;
            
            // 顏色邏輯
            if (i === currentTX) {
                ctx.fillStyle = '#ff4757'; // TX
            } else {
                // 如果該 Bar 超過 70% 的 Scale，顯示黃色警告
                const intensity = barHeight / h;
                ctx.fillStyle = intensity > 0.7 ? '#ffeb3b' : '#00d2ff';
            }

            ctx.fillRect(x + 1, y, barW - 2, barHeight);
        });

        // 5. 在圖表左上角顯示目前的 Scale Range
        ctx.fillStyle = '#666';
        ctx.font = '10px Arial';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        ctx.fillText(`Scale: 0 ~ ${(scaleCeiling * 1000).toFixed(0)} mV`, 5, 5);
    }

    function drawPhysicalView() {
        const ctx = ctxEIT;
        const cx = CONFIG.center_x;
        const cy = CONFIG.center_y;
        const r_out = CONFIG.radius_outer;
        const r_in = r_out - CONFIG.elec_width;

        ctx.clearRect(0, 0, 600, 600);

        ctx.beginPath(); ctx.arc(cx, cy, r_out + 10, 0, Math.PI*2);
        ctx.strokeStyle = '#444'; ctx.lineWidth = 1; ctx.stroke();

        ctx.beginPath(); ctx.arc(cx, cy, r_in, 0, Math.PI*2);
        ctx.fillStyle = '#181b21'; ctx.fill();
        ctx.strokeStyle = '#00d2ff'; ctx.lineWidth = 0.5; ctx.stroke();

        if (touchPoint) {
            const tx = electrodes[currentTX];
            electrodes.forEach((rx, i) => {
                if (i === currentTX) return;
                const delta = Math.abs(rx.baseV - rx.currentV);
                if (delta > 0.1) {
                    ctx.beginPath();
                    ctx.moveTo(tx.cx, tx.cy);
                    const cpX = (tx.cx + rx.cx)/2 + (touchPoint.x - cx)*0.3;
                    const cpY = (tx.cy + rx.cy)/2 + (touchPoint.y - cy)*0.3;
                    ctx.quadraticCurveTo(cpX, cpY, rx.cx, rx.cy);
                    ctx.strokeStyle = `rgba(0, 210, 255, ${Math.min(1, delta * 1.5)})`;
                    ctx.lineWidth = 1; ctx.stroke();
                }
            });
        }

        electrodes.forEach((e, i) => {
            ctx.beginPath();
            ctx.arc(cx, cy, r_out, e.startAngle, e.endAngle);
            ctx.arc(cx, cy, r_in, e.endAngle, e.startAngle, true);
            ctx.closePath();
            
            ctx.fillStyle = (i === currentTX) ? '#ff4757' : '#eccc68';
            if (i === currentTX) { ctx.shadowBlur = 10; ctx.shadowColor = '#ff4757'; }
            else { ctx.shadowBlur = 0; }
            
            if (i !== currentTX && Math.abs(e.baseV - e.currentV) > 0.1) ctx.fillStyle = '#00d2ff';

            ctx.fill(); ctx.stroke();

            const labelR = r_in - 15;
            const lx = cx + labelR * Math.cos(e.midAngle);
            const ly = cy + labelR * Math.sin(e.midAngle);
            ctx.fillStyle = '#aaa'; ctx.font = '10px Arial'; 
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(e.id, lx, ly);
        });

        if (touchPoint) {
            ctx.beginPath(); ctx.arc(touchPoint.x, touchPoint.y, 10, 0, Math.PI*2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)'; ctx.fill();
            ctx.strokeStyle = 'rgba(255,255,255,0.5)'; ctx.stroke();
        }
    }

    function drawHeatmap() {
        const w = 200, h = 200;
        ctxHeat.clearRect(0, 0, w, h);
        if (!touchPoint) { ctxHeat.fillStyle = '#000'; ctxHeat.fillRect(0,0,w,h); return; }

        const imgData = ctxHeat.createImageData(w, h);
        const data = imgData.data;
        const scale = w / 600; 
        const tx = touchPoint.x * scale;
        const ty = touchPoint.y * scale;

        for (let y=0; y<h; y++) {
            for (let x=0; x<w; x++) {
                const dist = Math.hypot(x - tx, y - ty);
                if (dist < 35) {
                    const intensity = Math.max(0, 255 - dist * 6);
                    const idx = (y * w + x) * 4;
                    data[idx] = intensity; data[idx+1] = intensity * 0.8; data[idx+2] = 50; data[idx+3] = 255;
                }
            }
        }
        ctxHeat.putImageData(imgData, 0, 0);
    }

    function calculatePosition() {
        if(!touchPoint) return;
        let sumX = 0, sumY = 0, totalWeight = 0, maxDelta = 0;

        electrodes.forEach((e, i) => {
            if (i === currentTX) return;
            const delta = Math.abs(e.baseV - e.currentV);
            if (delta > maxDelta) maxDelta = delta;
            const weight = Math.pow(delta, 3);
            sumX += e.cx * weight; sumY += e.cy * weight; totalWeight += weight;
        });

        if (totalWeight > 0.001) {
            const dispX = Math.round(sumX / totalWeight - CONFIG.center_x);
            const dispY = Math.round(sumY / totalWeight - CONFIG.center_y);
            
            document.getElementById('coordDisplay').innerText = `${dispX} , ${dispY}`;
            document.getElementById('peakDisplay').innerText = (maxDelta * 1000).toFixed(0) + " mV";

            const err = Math.hypot((touchPoint.x - CONFIG.center_x) - dispX, (touchPoint.y - CONFIG.center_y) - dispY);
            document.getElementById('accDisplay').innerText = Math.max(0, 100 - err).toFixed(1) + "%";
        }
    }

    function updateTable() {
        const tbody = document.getElementById('voltageBody');
        let sorted = [...electrodes].sort((a, b) => a.id - b.id);
        let html = '';
        
        // 用同樣的 Max Delta 來縮放表格進度條，保持視覺一致
        let maxDelta = 0.001;
        electrodes.forEach(e => {
            if(e.id !== currentTX +1) {
                const d = Math.abs(e.baseV - e.currentV);
                if(d > maxDelta) maxDelta = d;
            }
        });

        sorted.forEach(e => {
            if (e.id === currentTX + 1) return;
            const delta = (e.baseV - e.currentV) * 1000;
            const absDelta = Math.abs(delta);
            
            // 表格內的 Bar 也跟隨動態比例
            const width = (absDelta / (maxDelta * 1000)) * 100;
            const isHigh = absDelta > 200;
            
            html += `<tr>
                <td>CH${e.id}</td>
                <td>${e.baseV.toFixed(2)}</td>
                <td>${e.currentV.toFixed(2)}</td>
                <td class="${isHigh ? 'high-delta' : ''}">${delta.toFixed(1)}</td>
                <td><div class="bar-container"><div class="bar-fill" style="width:${width}%; background:${isHigh?'#ffeb3b':'#00d2ff'}"></div></div></td>
            </tr>`;
        });
        tbody.innerHTML = html;
    }

    const canvas = document.getElementById('eitCanvas');
    function getMousePos(evt) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = 600 / rect.width;
        const scaleY = 600 / rect.height;
        const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
        const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;
        return { x: (clientX - rect.left) * scaleX, y: (clientY - rect.top) * scaleY };
    }
    function handleInput(x, y) {
        const dist = Math.hypot(x - CONFIG.center_x, y - CONFIG.center_y);
        if (dist < CONFIG.radius_outer) { touchPoint = { x, y }; }
    }
    ['mousedown', 'mousemove'].forEach(evt => 
        canvas.addEventListener(evt, e => { if(e.buttons===1 || evt==='mousedown') handleInput(getMousePos(e).x, getMousePos(e).y) })
    );
    ['touchstart', 'touchmove'].forEach(evt => 
        canvas.addEventListener(evt, e => { e.preventDefault(); handleInput(getMousePos(e).x, getMousePos(e).y) }, {passive: false})
    );

    function clearTouch() {
        touchPoint = null;
        document.getElementById('coordDisplay').innerText = "-- , --";
        document.getElementById('accDisplay').innerText = "--%";
        document.getElementById('peakDisplay').innerText = "0 mV";
    }

    function toggleAutoScan() {
        const btn = document.getElementById('btnScan');
        if (isScanning) {
            clearInterval(scanTimer); isScanning = false;
            btn.innerText = "Auto Scan"; btn.classList.remove('danger');
        } else {
            isScanning = true;
            btn.innerText = "Stop"; btn.classList.add('danger');
            scanTimer = setInterval(() => { currentTX = (currentTX + 1) % CONFIG.electrodes; }, 200);
        }
    }

    init();
</script>
</body>
</html>
